use anyhow::{anyhow, Result};
use serde_json::{json, Value};
use std::time::Duration;

/// Fetch full transaction details using NEAR RPC `tx` method
///
/// This method queries archival RPC for comprehensive transaction data:
/// - Transaction body (actions, signer, receiver, nonce, etc.)
/// - All receipts generated by the transaction
/// - Receipts outcome (execution results for each receipt)
/// - Complete transaction lifecycle
///
/// Uses `tx` method which is designed for archival transaction lookups.
/// Falls back from live RPC to archival RPC if transaction not found.
/// Requires Bearer token authentication for FastNEAR RPC endpoints.
pub async fn fetch_transaction_details(
    rpc_url: &str,
    archival_rpc_url: Option<&str>,
    tx_hash: &str,
    signer_account_id: &str,
    timeout_ms: u64,
    auth_token: Option<&str>,
) -> Result<Value> {
    let client = crate::rpc_utils::http_client();

    // Try live RPC first
    log::info!("[tx_details_rpc] Fetching tx {} from live RPC: {}", tx_hash, rpc_url);

    match fetch_tx_from_rpc(&client, rpc_url, tx_hash, signer_account_id, timeout_ms, auth_token).await {
        Ok(tx_data) => {
            log::info!("[tx_details_rpc] ✅ Found transaction on live RPC");
            return Ok(tx_data);
        }
        Err(e) => {
            // Check if error is "unknown transaction" - if so, try archival
            let error_msg = e.to_string().to_lowercase();
            if error_msg.contains("unknown") || error_msg.contains("not found") || error_msg.contains("does not exist") {
                if let Some(archival_url) = archival_rpc_url {
                    log::info!("[tx_details_rpc] Transaction not on live RPC, trying archival: {}", archival_url);

                    match fetch_tx_from_rpc(&client, archival_url, tx_hash, signer_account_id, timeout_ms, auth_token).await {
                        Ok(tx_data) => {
                            log::info!("[tx_details_rpc] ✅ Found transaction on archival RPC");
                            return Ok(tx_data);
                        }
                        Err(archival_err) => {
                            log::error!("[tx_details_rpc] Transaction not found on archival RPC: {}", archival_err);
                            return Err(anyhow!("Transaction not found on live or archival RPC: {}", archival_err));
                        }
                    }
                } else {
                    log::error!("[tx_details_rpc] Transaction not on live RPC and no archival URL configured");
                    return Err(e);
                }
            } else {
                // Some other error (network, timeout, etc.)
                log::error!("[tx_details_rpc] RPC error: {}", e);
                return Err(e);
            }
        }
    }
}

/// Internal helper: Fetch transaction from a specific RPC endpoint
async fn fetch_tx_from_rpc(
    client: &reqwest::Client,
    rpc_url: &str,
    tx_hash: &str,
    signer_account_id: &str,
    timeout_ms: u64,
    auth_token: Option<&str>,
) -> Result<Value> {
    let body = json!({
        "jsonrpc": "2.0",
        "id": "dontcare",
        "method": "tx",
        "params": [tx_hash, signer_account_id]
    });

    log::debug!("[tx_details_rpc] RPC request to {}: {}", rpc_url, serde_json::to_string(&body).unwrap_or_default());

    let mut request = client
        .post(rpc_url)
        .json(&body)
        .timeout(Duration::from_millis(timeout_ms));

    // Add Bearer token if provided
    if let Some(token) = auth_token {
        request = request.header("Authorization", format!("Bearer {}", token));
        log::debug!("[tx_details_rpc] Using Bearer token authentication");
    }

    let response = request
        .send()
        .await
        .map_err(|e| anyhow!("RPC request failed: {}", e))?;

    let status = response.status();
    if !status.is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(anyhow!("RPC HTTP error {}: {}", status, error_text));
    }

    let rpc_response: Value = response.json().await
        .map_err(|e| anyhow!("Failed to parse RPC response: {}", e))?;

    // Check for RPC error
    if let Some(error) = rpc_response.get("error") {
        let error_message = error["message"].as_str().unwrap_or("Unknown RPC error");
        let error_data = error["data"].as_str().unwrap_or("");
        return Err(anyhow!("RPC error: {} - {}", error_message, error_data));
    }

    // Extract result
    if let Some(result) = rpc_response.get("result") {
        log::debug!("[tx_details_rpc] Received transaction data with {} top-level keys",
                   result.as_object().map(|o| o.len()).unwrap_or(0));
        return Ok(result.clone());
    }

    Err(anyhow!("No result in RPC response"))
}