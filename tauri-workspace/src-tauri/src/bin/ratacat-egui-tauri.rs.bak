//! Ratacat egui + Tauri Integration
//!
//! Production-grade TUI embedded in egui, running inside Tauri for:
//! - Native desktop (OpenGL/glow)
//! - Deep link handling via Tauri
//! - Bearer token UI with localStorage persistence
//!
//! This binary uses egui_ratatui to render the full Ratacat TUI
//! inside an egui canvas, providing a single codebase for desktop.

#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use anyhow::Result;
use egui::{Align, CentralPanel, Layout, TopBottomPanel};
use egui_ratatui::RataguiBackend;
use ratacat::{App, AppEvent};
use ratatui::Terminal;
use embedded_graphics_unicodefonts::{
    mono_8x13_atlas, mono_8x13_bold_atlas, mono_8x13_italic_atlas,
};
use soft_ratatui::{SoftBackend, EmbeddedGraphics};
use std::sync::{Arc, Mutex};
use tauri::State;
use tauri_plugin_deep_link::DeepLinkExt;

#[cfg(not(target_arch = "wasm32"))]
use std::time::Instant;

#[cfg(target_arch = "wasm32")]
use web_time::Instant;

// ============================================================================
// State Management
// ============================================================================

/// Shared state between Tauri backend and egui frontend
#[derive(Clone)]
struct AppState {
    /// Ratacat app instance
    app: Arc<Mutex<App>>,
    /// Channel for blockchain events
    event_rx: Arc<Mutex<tokio::sync::mpsc::UnboundedReceiver<AppEvent>>>,
    /// Bearer token (for UI display/edit)
    bearer_token: Arc<Mutex<Option<String>>>,
    /// RPC URL (for UI display/edit)
    rpc_url: Arc<Mutex<String>>,
}

// ============================================================================
// Tauri Commands
// ============================================================================

#[tauri::command]
fn get_bearer_token(state: State<AppState>) -> Option<String> {
    state.bearer_token.lock().unwrap().clone()
}

#[tauri::command]
fn set_bearer_token(state: State<AppState>, token: Option<String>) {
    *state.bearer_token.lock().unwrap() = token;
    // TODO: Update RPC client with new token
}

#[tauri::command]
fn get_rpc_url(state: State<AppState>) -> String {
    state.rpc_url.lock().unwrap().clone()
}

#[tauri::command]
fn set_rpc_url(state: State<AppState>, url: String) {
    *state.rpc_url.lock().unwrap() = url;
    // TODO: Restart RPC client with new URL
}

// ============================================================================
// egui Application
// ============================================================================

struct RatacatEguiApp {
    /// Ratatui terminal with egui_ratatui backend
    terminal: Terminal<RataguiBackend<SoftBackend<EmbeddedGraphics>>>,
    /// Shared app state
    state: AppState,
    /// Settings panel expanded
    settings_open: bool,
    /// Bearer token editor (temporary, synced on save)
    bearer_edit: String,
    /// RPC URL editor (temporary, synced on save)
    rpc_edit: String,
}

impl RatacatEguiApp {
    fn new(_cc: &eframe::CreationContext<'_>, state: AppState) -> Self {
        // Create software-rendered ratatui backend using EmbeddedGraphics directly
        let font_regular = mono_8x13_atlas();
        let font_bold = mono_8x13_bold_atlas();
        let font_italic = mono_8x13_italic_atlas();

        let soft = SoftBackend::<EmbeddedGraphics>::new(
            120, // initial cols
            40,  // initial rows
            font_regular,
            Some(font_bold),
            Some(font_italic),
        );

        let backend = RataguiBackend::new("ratacat", soft);
        let terminal = Terminal::new(backend).expect("Failed to create terminal");

        let bearer_edit = state.bearer_token.lock().unwrap().clone().unwrap_or_default();
        let rpc_edit = state.rpc_url.lock().unwrap().clone();

        Self {
            terminal,
            state,
            settings_open: false,
            bearer_edit,
            rpc_edit,
        }
    }

    fn process_events(&mut self) {
        // Drain blockchain events and update app state
        if let Ok(mut rx) = self.state.event_rx.try_lock() {
            let mut count = 0;
            while let Ok(event) = rx.try_recv() {
                if let Ok(mut app) = self.state.app.try_lock() {
                    app.on_event(event);
                    count += 1;
                }
            }
            if count > 0 {
                log::debug!("Processed {} blockchain events", count);
            }
        }
    }

    fn draw_settings_panel(&mut self, ui: &mut egui::Ui) {
        ui.heading("âš™ Settings");
        ui.separator();

        // RPC URL
        ui.label("RPC URL:");
        ui.text_edit_singleline(&mut self.rpc_edit);
        if ui.button("ðŸ’¾ Save URL").clicked() {
            *self.state.rpc_url.lock().unwrap() = self.rpc_edit.clone();
            log::info!("RPC URL updated: {}", self.rpc_edit);
        }

        ui.add_space(8.0);

        // Bearer Token
        ui.label("Bearer Token:");
        let mut masked = self.bearer_edit.clone();
        if !masked.is_empty() {
            masked = format!("{}...", masked.chars().take(12).collect::<String>());
        }
        ui.label(format!("Current: {}", if masked.is_empty() { "none" } else { &masked }));

        ui.horizontal(|ui| {
            let response = ui.add(
                egui::TextEdit::singleline(&mut self.bearer_edit)
                    .password(true)
                    .hint_text("Paste token here"),
            );

            if ui.button("ðŸ’¾ Save Token").clicked() || response.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                let token = if self.bearer_edit.is_empty() {
                    None
                } else {
                    Some(self.bearer_edit.clone())
                };
                *self.state.bearer_token.lock().unwrap() = token;
                log::info!("Bearer token updated");
            }
        });

        ui.add_space(8.0);
        ui.separator();
        ui.label("ðŸ“ Token persists to localStorage on web, env var on native");
    }
}

impl eframe::App for RatacatEguiApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Process blockchain events
        self.process_events();

        // Top panel: controls
        TopBottomPanel::top("top_panel").show(ctx, |ui| {
            ui.with_layout(Layout::left_to_right(Align::Center), |ui| {
                ui.label("ðŸ± Ratacat");
                ui.separator();

                // Settings toggle
                if ui.button(if self.settings_open { "âš™ Hide Settings" } else { "âš™ Settings" }).clicked() {
                    self.settings_open = !self.settings_open;
                }

                ui.with_layout(Layout::right_to_left(Align::Center), |ui| {
                    let bearer_status = if self.state.bearer_token.lock().unwrap().is_some() {
                        "ðŸ” Authenticated"
                    } else {
                        "âš ï¸  No Bearer Token"
                    };
                    ui.label(bearer_status);
                });
            });
        });

        // Settings panel (collapsible)
        if self.settings_open {
            TopBottomPanel::top("settings_panel")
                .resizable(false)
                .show(ctx, |ui| {
                    self.draw_settings_panel(ui);
                });
        }

        // Central panel: Ratatui TUI
        CentralPanel::default().show(ctx, |ui| {
            // Draw ratatui UI
            if let Ok(mut app) = self.state.app.try_lock() {
                let _ = self.terminal.draw(|f| {
                    ratacat::ui::draw(f, &mut app, &[]); // Empty marks for now
                });
            }

            // Render the egui_ratatui widget
            ui.add(self.terminal.backend_mut());
        });

        // Request repaint for smooth animation
        ctx.request_repaint();
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main() -> Result<()> {
    env_logger::init();

    log::info!("ðŸš€ Ratacat egui-tauri starting...");

    // For now, create a minimal working app
    // TODO: Wire up RPC polling and config loading

    // Create blockchain event channel (unused for now)
    let (_event_tx, event_rx) = tokio::sync::mpsc::unbounded_channel();

    // Create app state with defaults
    let app = App::new(
        30,                                   // fps
        vec![20, 30, 60],                    // fps_choices
        100,                                  // keep_blocks
        "intents.near".to_string(),          // default_filter
        None,                                 // No archival fetch
    );

    let app_state = AppState {
        app: Arc::new(Mutex::new(app)),
        event_rx: Arc::new(Mutex::new(event_rx)),
        bearer_token: Arc::new(Mutex::new(None)),
        rpc_url: Arc::new(Mutex::new("https://rpc.mainnet.fastnear.com".to_string())),
    };

    // Start Tauri
    tauri::Builder::default()
        .plugin(tauri_plugin_deep_link::init())
        .manage(app_state.clone())
        .invoke_handler(tauri::generate_handler![
            get_bearer_token,
            set_bearer_token,
            get_rpc_url,
            set_rpc_url
        ])
        .setup(|app| {
            log::info!("âœ… Tauri setup complete");

            // Register deep link handler
            #[cfg(any(target_os = "linux", all(debug_assertions, windows)))]
            app.deep_link().register_all()?;

            // Handle initial deep link
            if let Some(urls) = app.deep_link().get_current()? {
                log::info!("ðŸ“Ž Initial deep links: {:?}", urls);
                // TODO: Convert to filter and update app state
            }

            // Handle runtime deep links
            let app_handle = app.handle().clone();
            app.deep_link().on_open_url(move |event| {
                let urls = event.urls();
                log::info!("ðŸ“Ž Runtime deep link: {:?}", urls);
                // TODO: Convert to filter and update app state
            });

            Ok(())
        })
        .build(tauri::generate_context!())
        .expect("error while building tauri application")
        .run(|_app_handle, event| {
            if let tauri::RunEvent::ExitRequested { .. } = event {
                log::info!("ðŸ‘‹ Ratacat shutting down");
            }
        });

    Ok(())
}
